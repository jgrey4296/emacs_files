* Helm Generic Help
** Basics

   To navigate in this Help buffer see [[Helm help][here]].

   Helm narrows down the list of candidates as you type a filter pattern see [[Matching in Helm][Matching in Helm]].

   Helm accepts multiple space-separated patterns, each pattern can be negated with \"!\".

   Helm also supports fuzzy matching in some places when specified, you will find
   several variables to enable fuzzy matching in diverse [[Helm sources][sources]],
   see [[https://github.com/emacs-helm/helm/wiki/Fuzzy-matching][fuzzy-matching]] in helm-wiki for more infos.

   Helm generally uses familiar Emacs keys to navigate the list.
   Here follow some of the less obvious bindings:

   - `\\<helm-map>\\[helm-maybe-exit-minibuffer]' selects the candidate from the list, executes the default action
   upon exiting the Helm session.

   - `\\<helm-map>\\[helm-execute-persistent-action]' executes the default action but without exiting the Helm session.
   Not all sources support this.

   - `\\<helm-map>\\[helm-select-action]' displays a list of actions available on current candidate or all marked candidates.
   The default binding <tab> is ordinarily used for completion, but that would be
   redundant since Helm completes upon every character entered in the prompt.
   See [[https://github.com/emacs-helm/helm/wiki#helm-completion-vs-emacs-completion][Helm wiki]].

   Note: In addition to the default actions list, additional actions appear
   depending of the type of the selected candidate(s).  They are called filtered
   actions.

** Helm sources

   Helm uses what's called sources to provide different kinds of completions, each helm session
   can handle one or more source.
   A source is an alist object which is build from various classes, see [[Writing your own Helm sources][here]]
   and [[https://github.com/emacs-helm/helm/wiki/Developing#creating-a-source][Helm wiki]] for more infos.

*** Configure sources

    You will find in helm sources already built and bound to a
    variable called generally `helm-source-<something>', in this case
    it is an alist and you can change the attributes (keys) values
    using `helm-attrset' function in your config, of course you have
    to ensure before calling `helm-attrset' that the file containing
    source is loaded with e.g. `with-eval-after-load'.  Of course you
    can also completely redefine the source but this is generally not
    elegant as it duplicate for its most part code already defined in
    Helm.

    You will find also sources that are not built and even not bound
    to any variables because they are rebuilded at each start of helm
    session.  In this case you can add a defmethod called
    `helm-setup-user-source' to your config:

    #+begin_src elisp

    (defmethod helm-setup-user-source ((source helm-moccur-class))
      (setf (slot-value source 'follow) -1))

    #+end_src

    See [[https://github.com/emacs-helm/helm/wiki/FAQ#why-is-a-customizable-helm-source-nil][here]] for more infos,
    and for more complex examples of configuration [[https://github.com/thierryvolpiatto/emacs-tv-config/blob/master/init-helm.el#L340][here]].

** Matching in Helm

   All what you write in minibuffer is interpreted as a regexp or
   multiple regexps if separated by a space.  This is true for most
   sources unless developer of source have disabled it or have choosen to
   use fuzzy matching.  Even if a source have fuzzy matching enabled,
   helm will switch to multi match as soon as it detect a space in
   pattern, it may also switch to multi match as well if pattern starts
   with a \"^\" beginning of line sign, in those cases each pattern
   separated with space should be a regexp and not a fuzzy pattern.  When
   using multi match patterns, each pattern starting with \"!\" is
   interpreted as a negation i.e. match everything but this.

*** Completion-styles

    Helm generally fetch its candidates with the :candidates function
    up to `helm-candidate-number-limit' and then apply match functions
    to these candidates according to `helm-pattern'.
    But Helm allows matching candidates directly from the :candidates
    function using its own `completion-styles'.
    Helm provides 'helm completion style but also 'helm-flex completion style
    for Emacs<27 that don't have 'flex completion style, otherwise (emacs-27)
    'flex completion style is used to provide fuzzy aka flex completion.
    By default, like in Emacs vanilla, all completion commands
    \(e.g. `completion-at-point') using `completion-in-region' or
    `completing-read' use `completion-styles'.
    Some Helm native commands like `helm-M-x' do use `completion-styles'.
    Any helm sources can use `completion-styles' by using :match-dynamic slot
    and building their :candidates function with `helm-dynamic-completion'.
    Example:

    #+begin_src elisp

    (helm :sources (helm-build-sync-source \"test\"
                     :candidates (helm-dynamic-completion
                                  '(foo bar baz foab)
                                  'symbolp)
                     :match-dynamic t)
          :buffer \"*helm test*\")

    #+end_src

    By default Helm setup `completion-styles' and always add 'helm to it, however
    the flex completion styles are not added, this is up to the user if she want to
    have such completion to enable this.
    As specified above use 'flex for emacs-27 and 'helm-flex for emacs-26.
    Anyway, 'helm-flex is not provided in `completion-styles-alist' if 'flex is present.

    Finally Helm provide two user variables to control `completion-styles' usage:
    `helm-completion-style' and `helm-completion-syles-alist'.
    Both variables are customizable.
    The former allows retrieving previous Helm behavior if needed, by setting it to
    `helm' or `helm-fuzzy', default being `emacs' which allows dynamic completion
    and usage of `completion-styles', the second allows setting `helm-completion-style'
    per mode and also specify `completion-styles' per mode (see its docstring).
    Note that these two variables take effect only in helm-mode i.e. in all what use
    `completion-read' or `completion-in-region', IOW all helmized commands.
    File completion in `read-file-name' family doesn't obey completion-styles and have their
    own file completion implementation.
    Native helm commands using `completion-styles' doesn't obey `helm-completion-style' and
    `helm-completion-syles-alist' (e.g. helm-M-x).

    Also for a better control of styles in native helm sources (not helmized by helm-mode)
    using :match-dynamic, `helm-dynamic-completion' provides a STYLES argument that allows
    specifying explicitely styles for this source.

    NOTE: Some old completion styles are not working fine with helm
    and are disabled by default in
    `helm-blacklist-completion-styles', they are anyway not useful in
    helm because 'helm style supersed these styles.

** Helm mode

   `helm-mode' toggles Helm completion in native Emacs functions,
   so when you turn `helm-mode' on, commands like `switch-to-buffer' will use
   Helm completion instead of the usual Emacs completion buffer.

*** What gets or does not get \"helmized\" when `helm-mode' is enabled?

    Helm provides generic completion on all Emacs functions using `completing-read',
    `completion-in-region' and their derivatives, e.g. `read-file-name'.  Helm
    exposes a user variable to control which function to use for a specific Emacs
    command: `helm-completing-read-handlers-alist'.  If the function for a specific
    command is nil, it turns off Helm completion.  See the variable documentation
    for more infos.

*** Helm functions vs helmized Emacs functions

    While there are Helm functions that perform the same completion as other
    helmized Emacs functions, e.g. `switch-to-buffer' and `helm-buffers-list', the
    native Helm functions like `helm-buffers-list' can receive new features, the
    allow marking candidates, they have several actions, etc.  Whereas the helmized
    Emacs functions only have Helm completion, one action and no more then Emacs can
    provide for this function.  This is the intended behavior.

    Generally you are better off using the native Helm command
    than the helmized Emacs equivalent.

*** Completion behavior with Helm and completion-at-point

    Helm is NOT completing dynamically, that's mean that when you are
    completing some text at point, completion is done against this
    text and subsequent characters you add AFTER this text, this
    allow you to use matching methods provided by Helm, that is multi
    matching or fuzzy matching (see [[Matching in Helm][Matching in Helm]]).

    Completion is not done dynamically (against `helm-pattern')
    because backend functions (i.e. `competion-at-point-functions')
    are not aware of the Helm matching methods.

    By behaving like this, the benefit is that you can fully use Helm
    matching methods but you can't start a full completion against a
    prefix different than the initial text you have at point, Helm
    warn you against this by colorizing the initial input and send an
    user-error message when trying to delete backward text beyond
    this limit at first hit on DEL and on second hit on DEL within a
    short delay (1s) quit Helm and delete-backward char in
    current-buffer.

** Helm help

   \\[helm-documentation]: Show all helm documentations concatenated in one org file.

   From a Helm session, just hit \\<helm-map>\\[helm-help] to have the
   documentation for the current source followed by the global Helm documentation.

   While in the help buffer, most of the Emacs regular keybindings
   are available; the most important ones are shown in minibuffer.
   However due to the implementation restrictions, no regular Emacs
   keymap is used (it runs in a loop when reading the help buffer)
   they are hardcoded and not modifiable.

   The hard-coded documentation bindings are:

   | Key       | Alternative keys | Command             |
   |-----------+------------------+---------------------|
   | C-v       | Space next       | Scroll up           |
   | M-v       | b prior          | Scroll down         |
   | C-s       |                  | Isearch forward     |
   | C-r       |                  | Isearch backward    |
   | C-a       |                  | Beginning of line   |
   | C-e       |                  | End of line         |
   | C-f       | right            | Forward char        |
   | C-b       | left             | Backward char       |
   | C-n       | down             | Next line           |
   | C-p       | up               | Previous line       |
   | M-a       |                  | Backward sentence   |
   | M-e       |                  | Forward sentence    |
   | M-f       |                  | Forward word        |
   | M-b       |                  | Backward word       |
   | M->       |                  | End of buffer       |
   | M-<       |                  | Beginning of buffer |
   | C-<SPACE> |                  | Toggle mark         |
   | RET       |                  | Follow org link     |
   | C-%       |                  | Push org mark       |
   | C-&       |                  | Goto org mark-ring  |
   | TAB       |                  | Org cycle           |
   | M-<TAB>   |                  | Toggle visibility   |
   | M-w       |                  | Copy region         |
   | q         |                  | Quit                |

** Customize Helm

   Helm provides a lot of user variables for extensive customization.
   From any Helm session, type \\<helm-map>\\[helm-customize-group] to jump to the current source `custom' group.
   Helm also has a special group for faces you can access via `M-x customize-group RET helm-faces'.

   Note: Some sources may not have their group set and default to the `helm' group.

** Display Helm in windows and frames

   You can display the helm completion buffer in many differents
   window configurations, see the custom interface to discover the
   different windows configurations available (See [[Customize Helm][Customize Helm]] to jump to custom interface).
   When using Emacs in a graphic display (i.e. not in a terminal) you can as
   well display your helm buffers in separated frames globally for
   all helm commands or separately for specific helm commands.
   See [[https://github.com/emacs-helm/helm/wiki/frame][helm wiki]] for more infos.

** Helm's basic operations and default key bindings

   | Key     | Alternative Keys | Command                                                              |
   |---------+------------------+----------------------------------------------------------------------|
   | C-p     | Up               | Previous line                                                        |
   | C-n     | Down             | Next line                                                            |
   | M-v     | prior            | Previous page                                                        |
   | C-v     | next             | Next page                                                            |
   | Enter   |                  | Execute first (default) action / Select [1]                          |
   | M-<     |                  | First line                                                           |
   | M->     |                  | Last line                                                            |
   | C-M-S-v | M-prior, C-M-y   | Previous page (other-window)                                         |
   | C-M-v   | M-next           | Next page (other-window)                                             |
   | Tab     | C-i              | Show action list                                                     |
   | M-o     |                  | Previous source                                                      |
   | C-o     |                  | Next source                                                          |
   | C-k     |                  | Delete pattern (with prefix arg delete from point to end or all [2]) |
   | C-j     |                  | Persistent action (Execute and keep Helm session)                    |

   \[1] Behavior may change depending context in some source e.g. `helm-find-files'.

   \[2] Delete from point to end or all depending on the value of
   `helm-delete-minibuffer-contents-from-point'.

** Action transformers

   You may be surprized to see you actions list changing depending of context, this
   happen when a source have an action transformer function which check the current
   candidate selectioned and add specific actions for this candidate.

** Shortcuts for n-th first actions

   f1-f12: Execute n-th action where n is 1 to 12.

** Shortcuts for executing the default action on the n-th candidate

   Helm does not display line numbers by default, with Emacs-26+
   you can enable it permanently in all helm buffers with:

   (add-hook 'helm-after-initialize-hook 'helm-init-relative-display-line-numbers)

   You can also toggle line numbers with \\<helm-map>\\[helm-display-line-numbers-mode] in current helm buffer.

   Of course when enabling `global-display-line-numbers-mode' helm buffers will have line numbers as well.
   \(don't forget to customize `display-line-numbers-type' to relative).

   In Emacs versions < to 26 you will have to use [[https://github.com/coldnew/linum-relative][linum-relative]] package
   and `helm-linum-relative-mode'.

   Then when line numbers are enabled with one of the methods above
   the following keys are available([1]):

   C-x <n>: Execute default action on the n-th candidate before currently selected candidate.

   C-c <n>: Execute default action on the n-th candidate after current selected candidate.

   \"n\" is limited to 1-9.  For larger jumps use other navigation keys.

   \[1] Note that the keybindings are always available even if line numbers are not displayed,
   they are just useless in this case.

** Mouse control in Helm

   A basic support for the mouse is provided when the user sets `helm-allow-mouse' to non-nil.

   - mouse-1 selects the candidate.
   - mouse-2 executes the default action on selected candidate.
   - mouse-3 pops up the action menu.

   Note: When mouse control is enabled in Helm, it also lets you click around and lose
   the minibuffer focus: you'll have to click on the Helm buffer or the minibuffer
   to retrieve control of your Helm session.

** Marked candidates

   You can mark candidates to execute an action on all of them instead of the
   current selected candidate only.  (See bindings below.)  Most Helm actions
   operate on marked candidates unless candidate-marking is explicitely forbidden
   for a specific source.

   - To mark/unmark a candidate, use \\[helm-toggle-visible-mark].  (See bindings below.)
   With a numeric prefix arg mark ARG candidates forward, if ARG is negative
   mark ARG candidates backward.

   - To mark all visible unmarked candidates at once in current source use \\[helm-mark-all].
   With a prefix argument, mark all candidates in all sources.

   - To unmark all visible marked candidates at once use \\[helm-unmark-all].

   - To mark/unmark all candidates at once use \\[helm-toggle-all-marks].
   With a prefix argument, mark/unmark all candidates in all sources.

   Note: When multiple candidates are selected across different sources, only the
   candidates of the current source will be used when executing most actions (as
   different sources can have different actions).  Some actions support
   multi-source marking however.

** Follow candidates

   When `helm-follow-mode' is on (\\<helm-map>\\[helm-follow-mode] to toggle it),
   moving up and down the Helm session or updating the list of candidates will
   automatically execute the persistent-action as specified for the current source.

   If `helm-follow-mode-persistent' is non-nil, the state of the mode will be
   restored for the following Helm sessions.

   If you just want to follow candidates occasionally without enabling
   `helm-follow-mode', you can use \\<helm-map>\\[helm-follow-action-forward] or \\[helm-follow-action-backward] instead.
   Conversely, when `helm-follow-mode' is enabled, those commands
   go to previous/next line without executing the persistent action.

** Frequently Used Commands

   \\[helm-toggle-resplit-and-swap-windows]\t\tToggle vertical/horizontal split on first hit and swap Helm window on second hit.
   \\[helm-exchange-minibuffer-and-header-line]\t\tExchange minibuffer and header-line.
   \\[helm-quit-and-find-file]\t\tDrop into `helm-find-files'.
   \\[helm-kill-selection-and-quit]\t\tKill display value of candidate and quit (with prefix arg, kill the real value).
   \\[helm-yank-selection]\t\tYank current selection into pattern.
   \\[helm-copy-to-buffer]\t\tCopy selected candidate at point in current buffer.
   \\[helm-follow-mode]\t\tToggle automatic execution of persistent action.
   \\[helm-follow-action-forward]\tRun persistent action then select next line.
   \\[helm-follow-action-backward]\t\tRun persistent action then select previous line.
   \\[helm-refresh]\t\tRecalculate and redisplay candidates.
   \\[helm-toggle-suspend-update]\t\tToggle candidate updates.

** Special yes, no or yes for all answers

   You may be prompted in the minibuffer to answer by [y,n,!,q] in some places
   for confirmation.

   - y  mean yes
   - no mean no
   - !  mean yes for all
   - q  mean quit or abort current operation.

   When using ! you will not be prompted anymore for the same thing in current operation
   e.g. file deletion, file copy etc...

** Moving in `helm-buffer'

   You can move in `helm-buffer' with the usual commands used in Emacs:
   \(\\<helm-map>\\[helm-next-line], \\<helm-map>\\[helm-previous-line], etc.  See above basic commands.
   When `helm-buffer' contains more than one source, change source with \\<helm-map>\\[helm-next-source] and \\[helm-previous-source].

   Note: When reaching the end of a source, \\<helm-map>\\[helm-next-line] will *not* go to the next source when
   variable `helm-move-to-line-cycle-in-source' is non-nil, so you will have to use \\<helm-map>\\[helm-next-source]
   and \\[helm-previous-source].

** Resume previous session from current Helm session

   You can use `C-c n' (`helm-run-cycle-resume') to cycle in resumables sources.
   `C-c n' is a special key set with `helm-define-key-with-subkeys' which, after pressing it, allows you
   to keep cycling with further `n'.

   Tip: You can bound the same key in `global-map' to `helm-cycle-resume'
   with `helm-define-key-with-subkeys' to let you transparently cycle
   sessions, Helm fired up or not.
   You can also bind the cycling commands to single key presses (e.g. `S-<f1>') this time
   with a simple `define-key'.  (Note that `S-<f1>' is not available in terminals.)

   Note: `helm-define-key-with-subkeys' is available only once Helm is loaded.

   You can also use \\<helm-map>\\[helm-resume-previous-session-after-quit] to resume
   the previous session, or \\<helm-map>\\[helm-resume-list-buffers-after-quit]
   to have completion on all resumable buffers.

** Global commands

*** Resume Helm session from outside Helm

    \\<global-map>\\[helm-resume] revives the last `helm' session.  Binding a key to
    this command will greatly improve `helm' interactivity, e.g. when quitting Helm
    accidentally.

    You can call \\<global-map>\\[helm-resume] with a prefix argument to choose
    \(with completion!) which session you'd like to resume.  You can also cycle in
    these sources with `helm-cycle-resume' (see above).

** Debugging Helm

   Helm exposes the special variable `helm-debug': setting it to non-nil
   will enable Helm logging in a special outline-mode buffer.
   Helm resets the variable to nil at the end of each session.

   For convenience, \\<helm-map>\\[helm-enable-or-switch-to-debug]
   allows you to turn on debugging for this session only.
   To avoid accumulating log entries while you are typing patterns, you can use
   \\<helm-map>\\[helm-toggle-suspend-update] to turn off updating.  When you
   are ready turn it on again to resume logging.

   Once you exit your Helm session you can access the debug buffer with
   `helm-debug-open-last-log'.  It is possible to save logs to dated files when
   `helm-debug-root-directory' is set to a valid directory.

   Note: Be aware that Helm log buffers grow really fast, so use `helm-debug' only
   when needed.

** Writing your own Helm sources

   Writing simple sources for your own usage is easy.  When calling the `helm'
   function, the sources are added the :sources slot which can be a symbol or a
   list of sources.  Sources can be built with different EIEIO classes depending
   what you want to do.  To simplify this, several `helm-build-*' macros are
   provided.  Below, simple examples to start with.

   We will not go further here, see [[https://github.com/emacs-helm/helm/wiki/Developing][Helm wiki]] and the source
   code for more information and more complex examples.

   #+begin_src elisp

    ;; Candidates are stored in a list.
    (helm :sources (helm-build-sync-source \"test\"
                     ;; A function can be used as well
                     ;; to provide candidates.
                     :candidates '(\"foo\" \"bar\" \"baz\"))
          :buffer \"*helm test*\")

    ;; Candidates are stored in a buffer.
    ;; Generally faster but doesn't allow a dynamic updating
    ;; of the candidates list i.e the list is fixed on start.
    (helm :sources (helm-build-in-buffer-source \"test\"
                     :data '(\"foo\" \"bar\" \"baz\"))
          :buffer \"*helm test*\")

   #+end_src

** Helm Map
   helm-map
   --------

   For more information check the manuals.

   Keymap for helm.

   key             binding
   ---             -------

   C-@             helm-toggle-visible-mark
   C-c             Prefix Command
   C-g             helm-keyboard-quit
   C-h             helm-next-source
   TAB             helm-execute-persistent-action
   C-j             helm-next-line
   C-k             kill-line
   C-l             Keyboard Macro
   RET             helm-maybe-exit-minibuffer
   C-n             helm-next-line
   C-o             helm-next-source
   C-p             helm-previous-line
   C-q             ace-jump-helm-line
   C-r             helm-minibuffer-history
   C-t             helm-toggle-resplit-and-swap-windows
   C-v             helm-next-page
   C-w             ??
   C-x             Prefix Command
   C-z             helm-select-action
   ESC             Prefix Command
   C-S-h           describe-key
   C-SPC           helm-toggle-visible-mark-forward
   C-!             helm-toggle-suspend-update
   C-{             helm-enlarge-window
   C-}             helm-narrow-window
   <C-M-down>      helm-scroll-other-window
   <C-M-up>        helm-scroll-other-window-down
   <C-down>        helm-follow-action-forward
   <C-up>          helm-follow-action-backward
   <M-next>        helm-scroll-other-window
   <M-prior>       helm-scroll-other-window-down
   <XF86Back>      previous-history-element
   <XF86Forward>   next-history-element
   <backtab>       helm-select-action
   <down>          helm-next-line
   <escape>        keyboard-escape-quit
   <f1>            ??
   <f10>           ??
   <f11>           ??
   <f12>           ??
   <f13>           ??
   <f2>            ??
   <f3>            ??
   <f4>            ??
   <f5>            ??
   <f6>            ??
   <f7>            ??
   <f8>            ??
   <f9>            ??
   <help>          Prefix Command
   <next>          helm-next-page
   <prior>         helm-previous-page
   <tab>           helm-execute-persistent-action
   <up>            helm-previous-line

   <help> m        helm-help

   C-c C-f         helm-follow-mode
   C-c TAB         helm-copy-to-buffer
   C-c C-k         helm-kill-selection-and-quit
   C-c C-u         helm-refresh
   C-c C-y         helm-yank-selection
   C-c %           helm-exchange-minibuffer-and-header-line
   C-c -           helm-swap-windows
   C-c 1           helm-execute-selection-action-at-nth-+1
   C-c 2           helm-execute-selection-action-at-nth-+2
   C-c 3           helm-execute-selection-action-at-nth-+3
   C-c 4           helm-execute-selection-action-at-nth-+4
   C-c 5           helm-execute-selection-action-at-nth-+5
   C-c 6           helm-execute-selection-action-at-nth-+6
   C-c 7           helm-execute-selection-action-at-nth-+7
   C-c 8           helm-execute-selection-action-at-nth-+8
   C-c 9           helm-execute-selection-action-at-nth-+9
   C-c >           helm-toggle-truncate-line
   C-c ?           helm-help
   C-c _           helm-toggle-full-frame
   C-c l           helm-display-line-numbers-mode
   C-c n           ??

   C-x C-b         helm-resume-list-buffers-after-quit
   C-x C-f         helm-quit-and-find-file
   C-x 1           helm-execute-selection-action-at-nth-+1
   C-x 2           helm-execute-selection-action-at-nth-+2
   C-x 3           helm-execute-selection-action-at-nth-+3
   C-x 4           helm-execute-selection-action-at-nth-+4
   C-x 5           helm-execute-selection-action-at-nth-+5
   C-x 6           helm-execute-selection-action-at-nth-+6
   C-x 7           helm-execute-selection-action-at-nth-+7
   C-x 8           helm-execute-selection-action-at-nth-+8
   C-x 9           helm-execute-selection-action-at-nth-+9
   C-x b           helm-resume-previous-session-after-quit

   C-M-a           helm-show-all-candidates-in-source
   C-M-e           helm-display-all-sources
   C-M-l           helm-reposition-window-other-window
   C-M-v           helm-scroll-other-window
   C-M-y           helm-scroll-other-window-down
   M-SPC           spacemacs/helm-navigation-transient-state/body
   M-(             helm-prev-visible-mark
   M-)             helm-next-visible-mark
   M-<             helm-beginning-of-buffer
   M->             helm-end-of-buffer
   M-U             helm-unmark-all
   M-a             helm-mark-all
   M-m             helm-toggle-all-marks
   M-n             next-history-element
   M-o             helm-previous-source
   M-p             previous-history-element
   M-v             helm-previous-page
   M-s-SPC         spacemacs/helm-navigation-transient-state/body
   C-M-S-v         helm-scroll-other-window-down

   C-c C-l         helm-minibuffer-history

   M-r             previous-matching-history-element
   M-s             next-matching-history-element
   (that binding is currently shadowed by another mode)

   "Message string containing detailed help for `helm'.
   It also accepts function or variable symbol.
