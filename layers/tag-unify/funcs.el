(defun tag-unify/process-candidates (x)
  (cons (s-replace-regexp ",? +" " " (car x))
        (cdr x))
  )
(defun tag-unify/build-bibtex-list ()
  (mapcar (lambda (x) (f-join tag-unify/loc-bibtex x))
          (-filter (lambda (x) (s-equals? (f-ext x) "bib"))
                   (directory-files tag-unify/loc-bibtex))))
(defun tag-unify/rebuild-tag-database ()
  ;; regenerate the master list of tags
  ;; from bookmarks

  ;; and from bibtex

  ;; and org
  )
(defun tag-unify/open-url-action (x)
  """ An action added to helm-grep for loading urls found
  in bookmarks "
  (let* ((marked (helm-marked-candidates))
         (no-props (mapcar (lambda (x) (substring-no-properties x 0 (length x))) marked))
         link-start-point
         )
    (with-temp-buffer
      (mapc (lambda (x) (insert (format "%s\n" x))) no-props)
      (goto-char (point-min))
      (while (not (equal (point) (point-max)))
        ;; (search-forward "href=\"")
        ;; (setq link-start-point (point))
        ;; (search-forward "\" TAGS")
        ;; (backward-char (length "\" TAGS"))
        (message "Opening: %s" (buffer-substring (line-beginning-position) (line-end-position)))
        (goto-char (line-beginning-position))
        (jg_org/open_link_externally)
        (forward-line)
        )
      )
    )
  )
(defun tag-unify/insert-candidates (x)
  (let ((candidates (helm-marked-candidates)))
    (with-helm-current-buffer
      (insert (mapconcat (lambda (x) (substring x 0 -2)) candidates "\n")))))
(defun tag-unify/insert-links (x)
  (let ((candidates (helm-marked-candidates)))
    (with-helm-current-buffer
      (insert (mapconcat (lambda (x) (format "[[%s][%s]]" (substring x 0 -2) (substring x 0 -2))) candidates "\n")))))
(defun tag-unify/tweet-link-action (candidate)
  (evil-window-new (get-buffer-window helm-current-buffer)
                   "*Link Tweeting*")
  (set (make-local-variable 'backup-inhibited) t)
  (auto-save-mode -1)
  (evil-window-set-height 10)
  (evil-initialize-local-keymaps)
  (evil-local-set-key 'normal
                      (kbd "C-c C-C") 'tag-unify/tweet-link-finish)
  (insert "\n")
  (insert candidate)
  (redraw-display)
  )
(defun tag-unify/tweet-link-finish ()
  (interactive)
  (let* ((text (buffer-substring-no-properties (point-min) (point-max))))
    (jg_twitter/twitter-tweet-text text nil '(jg_twitter/tweet_sentinel))
    ))
(defun tag-unify/grep-filter-one-by-one (candidate)
  (if (consp candidate)
      ;; Already computed do nothing (default as input).
      candidate
    (let* ((line   (helm--ansi-color-apply candidate))
           (split  (helm-grep-split-line line))
           ;; Normalize Size of this:
           (lineno (nth 1 split))
           (norm_ln (s-append (s-repeat (- 6 (string-width lineno)) " ") lineno))
           ;; The Actual Line:
           (str    (nth 2 split))
           (sub    (substring str (or (s-index-of "HREF=" str) 0)))
           (tag_index (s-index-of "TAGS=" sub))
           (url (substring sub (string-width "HREF=\"") tag_index))
           (tags (substring sub (+ (string-width "HREF=\"") (or tag_index 0)) (s-index-of ">" sub)))
           (chopped_tags (substring tags 0 (min 50 (string-width tags))))
           (norm_tags (s-append (s-repeat (- 50 (string-width chopped_tags)) " ") chopped_tags))
           )
      (cons (concat (propertize norm_ln 'face 'helm-grep-lineno)
                    (propertize (concat ": " norm_tags) 'face 'rainbow-delimiters-depth-3-face)
                    (propertize (concat ": " url) 'face 'rainbow-delimiters-depth-1-face))
            (or url line))
      )
    )
  )
(defun tag-unify/wrap-numbers (a b)
  (interactive "r")
  (message "%s %s" a b )
  (goto-char a)
  (while (re-search-forward "^[[:space:]]*\\([[:digit:]]+\\)[.)] " b t)
    (replace-match "\n(\\1)")
    )
  )
(defun tag-unify/map-entries-clean-whitespace ()
  "Called with org-map-entries. reduces whitespace prior
to point to a single new line"
  (set-marker tag-unify/org-clean-marker (line-end-position))
  (if (not (eq (point) (point-min)))
      (progn
        (while (eq 0 (string-match "^[[:space:]]*$"
                                   (buffer-substring
                                    (line-beginning-position 0)
                                    (line-end-position 0))))
          (join-line))
        (if (not (string-equal "*" (buffer-substring
                                    (line-beginning-position 0)
                                    (+ 1 (line-beginning-position 0)))))
            (insert "\n"))
        (setq org-map-continue-from tag-unify/org-clean-marker)
        )
    )
  )
(defun tag-unify/clean-org ()
  (interactive)
  (message "Starting Org Clean")

  (message "Hiding Properties")
  ;; indent region
  (spacemacs/indent-region-or-buffer)
  (whitespace-cleanup)
  ;; fill
  (fill-region (point-min) (point-max))

  ;;Reset to beginning
  (goto-char (point-min))
  ;;Find all pic.twitter's and ensure on new line
  (message "Finding pic.twitter's")
  (while (search-forward "pic.twitter" nil t)
    (let ((sub (buffer-substring (line-beginning-position) (point))))
      (if (not (eq 0 (string-match "^[[:space:]]+pic.twitter" sub)))
          (progn
            (backward-char (+ 1 (length "pic.twitter")))
            (insert "\n\n")))
      (progn (while (eq 0 (string-match "^[[:space:]]*$" (buffer-substring (line-beginning-position -0)
                                                                           (line-end-position -0))))
               (join-line)
               )
             (goto-char (line-beginning-position))
             (insert "\n")
             (forward-line))
      )
    )
  ;; Clean Whitespace
  (message "Cleaning Whitespace")
  (setq tag-unify/org-clean-marker (make-marker))
  (org-map-entries 'tag-unify/map-entries-clean-whitespace t nil)
  (set-marker tag-unify/org-clean-marker nil)

  (goto-char (point-min))
  (while (null (org-next-link))
    (let ((prev-line (buffer-substring (line-beginning-position 0)
                                       (line-end-position 0))))
      ;; (debug)
      (set-marker tag-unify/org-clean-marker (point))
      (cond  ((eq 0 (string-match "^[[:space:]]+:PERMALINK:" prev-line))
              (join-line))
             ((eq 0 (string-match "^[[:space:]]+:PROPERTIES:" prev-line))
              nil)
             ((not (eq 0 (string-match "^[[:space:]]*$" (buffer-substring
                                                         (line-beginning-position)
                                                         tag-unify/org-clean-marker))))
              (insert "\n")
              (let ((lnk (assq :link (org-context))))
                (if lnk
                    (goto-char (nth 2 lnk))
                  (forward-char 5)))
              )
             (t
              (while (eq 0 (string-match "^[[:space:]]*$" (buffer-substring
                                                           (line-beginning-position 0)
                                                           (line-end-position 0))))
                (join-line)
                )
              (let ((lnk (assq :link (org-context))))
                (if lnk
                    (goto-char (nth 2 lnk))
                  (forward-char 5)))
              )
             )
      )
    )
  (message "Indenting")
  (spacemacs/indent-region-or-buffer)
  (whitespace-cleanup)
  (setq tag-unify/org-clean-marker nil)

  (goto-char (point-min))
  (while (re-search-forward "]\\[\n[[:space:]]+" nil t)
    (replace-match "][")
    )
  (org-cycle-hide-drawers 'all)
  (message "Org Clean Finished")
  (goto-char (point-min ))
  )
(defun tag-unify/marked-file-fn (name)
  (message "----------")
  (message "Cleaning: %s" name)
  (with-temp-buffer
    (insert-file-contents name t)
    (write-file (format "%s_orig" name))
    (org-mode)
    (tag-unify/clean-org)
    (write-file name)
    )
  (message "Finished Cleaning")
  )
(defun tag-unify/clean-marked-files ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (seq-each 'tag-unify/marked-file-fn files)
    )
  )
(defun tag-unify/chop-long-file (name)
  (message "----------")
  (message "Chopping: %s" name)
  (with-temp-buffer
    (insert-file-contents name t)
    (goto-char (point-min))
    (let* ((count 1)
           (base_name (file-name-sans-extension name))
           (internal_name (buffer-substring (+ 2 (point-min)) (line-end-position)))
           (master_name (format "%s_master.org" base_name))
           (regexp "^\\*\\*[^*]")
           (last-position (re-search-forward regexp nil t))
           (linecount 0)
           (fn-fn (lambda () (format "%s_%s.org" base_name count)))
           (ln-fn (lambda (a b) (- (line-number-at-pos (max a b))
                                   (line-number-at-pos (min a b)))))
           )
      (append-to-file (format "* %s\n" internal_name) nil master_name)
      (while (re-search-forward "^\\*\\*[^*]" nil t )
        (if (not (file-exists-p (funcall fn-fn)))
            (progn (message "Creating %s" (funcall fn-fn))
                   (append-to-file (format "* %s %s\n" internal_name count) nil (funcall fn-fn))
                   (append-to-file (format "** [[%s][%s %s]]\n" (funcall fn-fn) internal_name count) nil master_name)
                   )
          )
        (append-to-file "\n** " nil (funcall fn-fn))
        (append-to-file last-position (line-beginning-position) (funcall fn-fn))
        (setq linecount (+ linecount (funcall ln-fn (point) last-position))
              last-position (point))
        (if (> linecount tag-unify/preferred-linecount-for-org)
            (setq linecount 0
                  count (+ 1 count))
          )
        )
      (append-to-file "\n** " nil (funcall fn-fn))
      (append-to-file last-position (point-max) (funcall fn-fn))
      )
    )
  )
(defun tag-unify/chop-long-files-from-dired ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (seq-each 'tag-unify/chop-long-file files)
    )
  )
(defun tag-unify/unify-pdf-locations-in-file (name)
  (message "Unifying Locations in %s" name)
  (with-temp-buffer
    (insert-file-contents name t)
    (goto-char (point-min))
    (while (re-search-forward "file ?= ?{\\(.+mega\\)/" nil t)
      (replace-match "~/Mega" nil nil nil 1)
      )
    (write-file name)
    )
  )
(defun tag-unify/unify-pdf-locations ()
  (interactive)
  (let ((files (dired-get-marked-files)))
    (seq-each 'tag-unify/unify-pdf-locations-in-file files)
    )
  )
(defun tag-unify/wrap-non-link-urls ()
  (interactive)
  (let ((start (if (eq evil-state 'visual) evil-visual-beginning (point-min)))
        (last (if (eq evil-state 'visual) evil-visual-end  nil)))
    (goto-char start)
    (while (re-search-forward "[^[[]\\(http[^ …]+\\)" last t)
      (replace-match "[[\\1][ᵢ]]")
      )
    )
  )
(defun tag-unify/set-tags (x)
  (if (eq major-mode 'bibtex-mode)
      (tag-unify/bibtex-set-tags x)
    (tag-unify/org-set-tags x))
  )
(defun tag-unify/bibtex-set-tags (x)
  (let* ((visual-candidates (helm-marked-candidates))
         (actual-candidates (mapcar (lambda (x) (cadr (assoc x tag-unify/tag-unify-candidates-names))) visual-candidates))
         (prior-point 1)
         (end-line (cdr tag-unify/tag-unify-region))
         (current-tags '())
         (add-func (lambda (candidate)
                     (if (not (-contains? current-tags candidate))
                         (progn
                           (push candidate current-tags)
                           (puthash candidate 1 tag-unify/global-tags))
                       (progn
                         (setq current-tags (remove candidate current-tags))
                         (puthash candidate (- (gethash candidate tag-unify/global-tags) 1) tag-unify/global-tags))
                       )))
         )
    (save-excursion
      (goto-char (car tag-unify/tag-unify-region))
      (setq prior-point (- (point) 1))
      (while (and (/= prior-point (point)) (< (line-number-at-pos (point)) end-line))
        (progn (setq current-tags (split-string (bibtex-autokey-get-field "tags") "," t " ")
                     prior-point (point))
               (mapc add-func actual-candidates)
               (bibtex-set-field "tags" (string-join current-tags ","))
               (org-ref-bibtex-next-entry)
               )))
    )
  )
(defun tag-unify/org-set-tags (x)
  """ Toggle Selected Tags """
  (let* ((visual-candidates (helm-marked-candidates))
         (actual-candidates (mapcar (lambda (x) (cadr (assoc x tag-unify/tag-unify-candidates-names))) visual-candidates))
         (prior-point 1)
         (end-line (cdr tag-unify/tag-unify-region))
         (current-tags '())
         (add-func (lambda (candidate)
                     (if (not (-contains? current-tags candidate))
                         (progn
                           (push candidate current-tags)
                           (puthash candidate 1 tag-unify/global-tags))
                       (progn
                         (setq current-tags (remove candidate current-tags))
                         (puthash candidate (- (gethash candidate tag-unify/global-tags) 1) tag-unify/global-tags))
                       ))))
    (save-excursion
      (goto-char (car tag-unify/tag-unify-region))
      (setq prior-point (- (point) 1))
      (while (and (/= prior-point (point)) (< (line-number-at-pos (point)) end-line))
        (progn (setq current-tags (org-get-tags nil t)
                     prior-point (point))
               (mapc add-func actual-candidates)
               (org-set-tags current-tags)
               (org-forward-heading-same-level 1)
               )))))
(defun tag-unify/strip_spaces (str)
  (s-replace " " "_" (string-trim str))
  )
(defun tag-unify/set-new-tag (x)
  (if (eq major-mode 'bibtex-mode)
      (tag-unify/bibtex-set-new-tag x)
    (tag-unify/org-set-new-tag x))
  )
(defun tag-unify/bibtex-set-new-tag (x)
  (save-excursion
    (goto-char (car tag-unify/tag-unify-region))
    (let ((prior-point (- (point) 1))
          (end-line (cdr tag-unify/tag-unify-region))
          (stripped_tag (tag-unify/strip_spaces x))
          )
      (while (and (/= prior-point (point)) (< (line-number-at-pos (point)) end-line))
        (setq prior-point (point))
        (let* ((current-tags (split-string (bibtex-autokey-get-field "tags") "," t " ")))
          (if (not (-contains? current-tags stripped_tag))
              (progn
                (push stripped_tag current-tags)
                (puthash stripped_tag 1 tag-unify/global-tags)))
          (bibtex-set-field "tags" (string-join current-tags ","))
          (org-ref-bibtex-next-entry)
          ))))
  )
(defun tag-unify/org-set-new-tag (x)
  (save-excursion
    (goto-char (car tag-unify/tag-unify-region))
    (let ((prior-point (- (point) 1))
          (end-line (cdr tag-unify/tag-unify-region))
          (stripped_tag (tag-unify/strip_spaces x))
          )
      (while (and (/= prior-point (point)) (< (line-number-at-pos (point)) end-line))
        (setq prior-point (point))
        (let* ((current-tags (org-get-tags nil t)))
          (if (not (-contains? current-tags stripped_tag))
              (progn
                (push stripped_tag current-tags)
                (puthash stripped_tag 1 tag-unify/global-tags)))
          (org-set-tags current-tags)
          (org-forward-heading-same-level 1)
          )))))
(defun tag-unify/sort-candidates (ap bp)
  """ Sort candidates by colour then lexicographically """
  (let* ((a (car ap))
         (b (car bp))
         (aprop (get-text-property 0 'font-lock-face a))
         (bprop (get-text-property 0 'font-lock-face b))
         (lookup (lambda (x) (gethash (cadr x) tag-unify/global-tags))))
    (cond
     ((and aprop bprop (> (funcall lookup ap) (funcall lookup bp))) t)
     ((and aprop (not bprop)) t)
     ((and (not aprop) (not bprop) (> (funcall lookup ap) (funcall lookup bp))))
     )))
(defun tag-unify/tag-unify-candidates ()
  """ Given Candidates, colour them if they are assigned, then sort them  """
  (let* ((buffer-cand-tags (tag-unify/org-count-buffer-tags))
         (global-tags tag-unify/global-tags))
    (if (not (hash-table-empty-p global-tags))
        (let* ((cand-keys (hash-table-keys global-tags))
               (cand-vals (hash-table-values global-tags))
               (cand-pairs (-zip cand-keys cand-vals))
               (maxTagLength (apply 'max (mapcar 'length cand-keys)))
               (maxTagAmount (apply 'max cand-vals))
               (bar-keys (tag-unify/make-bar-chart cand-pairs maxTagLength maxTagAmount))
               (display-pairs (-zip bar-keys cand-keys))
               (current-tags (org-get-tags nil t))
               (propertied-tags (map 'list (lambda (candidate)
                                             (let ((candString (car candidate)))
                                               (if (-contains? current-tags (cdr candidate))
                                                   (progn (put-text-property 0 (length candString)
                                                                             'font-lock-face
                                                                             'rainbow-delimiters-depth-1-face
                                                                             candString)))
                                               `(,candString ,(cdr candidate)))) display-pairs))
               )
          (setq tag-unify/tag-unify-candidate-counts global-tags)
          (setq tag-unify/tag-unify-candidates-names (sort propertied-tags 'tag-unify/sort-candidates))
          )
      '()
      ))
  )
(defun tag-unify/make-bar-chart (data maxTagLength maxTagAmnt)
  (let* ((maxTagStrLen (length (number-to-string maxTagAmnt)))
         (maxTagLength-bounded (min 40 maxTagLength))
         (max-column (- fill-column (+ 3 maxTagLength-bounded maxTagStrLen 3 3)))
         (bar-div (/ (float max-column) maxTagAmnt)))
    (mapcar (lambda (x)
              (let* ((tag (car x))
                     (tag-len (length tag))
                     (tag-cut-len (min tag-len (- maxTagLength-bounded 3)))
                     (tag-truncated-p (> tag-len (- maxTagLength-bounded 3)))
                     (tag-substr (string-join `(,(substring tag nil tag-cut-len)
                                                ,(if tag-truncated-p "..."))))
                     (tag-final-len (length tag-substr))
                     (amount (cdr x))
                     (amount-str (number-to-string amount))
                     (sep-offset (- (+ 3 maxTagLength-bounded) tag-final-len))
                     (amount-offset (- maxTagStrLen (length amount-str)))
                     (bar-len (ceiling (* bar-div amount)))
                     )
                (string-join `(,tag-substr
                               ,(make-string sep-offset ?\ )
                               " : "
                               ,amount-str
                               ,(make-string amount-offset ?\ )
                               " : "
                               ,(make-string bar-len ?=)
                               ;; "\n"
                               )))) data)))
(defun tag-unify/org-count-buffer-tags ()
  (save-excursion ;;store where you are in the current
    (goto-char (point-min))
    ;;where to store tags:
    (let ((tag-set (make-hash-table :test 'equal)))
      ;;match all
      (while (not (eq nil (re-search-forward ":\\([[:graph:]]+\\):\\(\.\.\.\\)?\$" nil t)))
        ;;split tags into list
        (let* ((tags (split-string (match-string-no-properties 0) ":" t ":"))
               (filtered (seq-filter (lambda (x) (not (or (string-equal x "PROPERTIES")
                                                          (string-equal x "END")
                                                          (string-equal x "DATE")
                                                          ))) tags)))
          ;;increment counts
          (mapc (lambda (x) (puthash x (+ 1 (gethash x tag-set 0)) tag-set)) filtered)
          )
        )
      tag-set
      )
    )
  )
(defun tag-unify/tag-occurrences-in-open-buffers()
  """ retrieve all tags in all open buffers, print to a temporary buffer """
  (interactive)
  (let* ((allbuffers (buffer-list))
         (alltags (make-hash-table :test 'equal))
         (hashPairs nil)
         (sorted '())
         (maxTagLength 0)
         (maxTagAmnt 0))
    (map 'list (lambda (bufname)
                 ;; TODO quit on not an org file
                 (with-current-buffer bufname
                   (let ((buftags (tag-unify/org-count-buffer-tags)))
                     (maphash (lambda (k v)
                                (puthash k (+ v (gethash k alltags 0)) alltags))
                              buftags)
                     ))) allbuffers)
    (setq hashPairs (-zip (hash-table-keys alltags) (hash-table-values alltags)))
    (if hashPairs (progn
                    (setq sorted (sort hashPairs (lambda (a b) (> (cdr a) (cdr b)))))
                    (setq maxTagLength (apply `max (mapcar (lambda (x) (length (car x))) sorted)))
                    (setq maxTagAmnt (apply `max (mapcar (lambda (x) (cdr x)) sorted)))
                    ))
    (with-temp-buffer-window "*Tags*"
                             nil
                             nil
                             (mapc (lambda (x) (princ (format "%s\n" x)))
                                   (tag-unify/make-bar-chart sorted maxTagLength maxTagAmnt))
                             )
    (tag-unify/org-format-temp-buffer "*Tags*" "All Files")
    )
  )
(defun tag-unify/tag-occurrences ()
  """ Count all occurrences of all tags and bar chart them """
  (interactive)
  ;;save eventually to a new buffer
  (let* ((tag-set (tag-unify/org-count-buffer-tags))
         (hashPairs (-zip (hash-table-keys tag-set) (hash-table-values tag-set)))
         (sorted (sort hashPairs (lambda (a b) (> (cdr a) (cdr b)))))
         (maxTagLength (apply `max (mapcar (lambda (x) (length (car x))) sorted)))
         (maxTagAmnt (apply `max (mapcar (lambda (x) (cdr x)) sorted)))
         (curr-buffer (buffer-name))
         )
    ;;print them all out

    (with-temp-buffer-window "*Tags*"
                             nil
                             nil
                             ;; Todo: Expand this func to group and add org headings
                             (mapc (lambda (x) (princ (format "%s\n" x)))
                                   (tag-unify/make-bar-chart sorted maxTagLength maxTagAmnt))
                             )
    (tag-unify/org-format-temp-buffer "*Tags*" curr-buffer)
    )
  )
(defun tag-unify/org-format-temp-buffer (name source_name)
  (with-current-buffer name
    (org-mode)
    (let ((inhibit-read-only 't)
          (last_num "-1")
          (get_num_re ": \\([[:digit:]]+\\) +:"))
      ;;Loop over all lines
      (goto-char (point-min))
      (insert "* Tag Summary for: " source_name "\n")
      (while (< (point) (point-max))
        (re-search-forward get_num_re nil 1)
        (if (string-equal last_num (match-string 1))
            (progn (beginning-of-line)
                   (insert "   ")
                   (forward-line))
          (progn (setq last_num (match-string 1))
                 (beginning-of-line)
                 (insert "** ")
                 (forward-line)))
        )))
  )
(defun tag-unify/org-split-temp-buffer-create (args)
  "Given a pair, create a temp buffer based on the cdr,
and insert the car "
  ;; (message "Creating Temp buffer for: %s" args)
  (with-temp-buffer-window (make-temp-name (cdr args)) nil nil
                           (org-mode)
                           (princ (car args))))
(defun tag-unify/org-split-on-headings ()
  " Split an org file into multiple smaller buffers non-destructively "
  (interactive)
  (let ((contents (buffer-substring (point-min) (point-max)))
        (target-depth (read-number "What Depth Subtrees to Copy? "))
        (orig-name (file-name-sans-extension (buffer-name)))
        (map-fn (lambda ()
                  (let* ((components (org-heading-components))
                         (depth (car components)))
                    ;;Only copy correct depths
                    (if (eq depth target-depth)
                        (progn
                          ;; (message (format "Current : %s %s" count (nth 4 components)))
                          (org-copy-subtree 1)
                          (current-kill 0 t)
                          )
                      )
                    )
                  ))
        results
        )
    (with-temp-buffer
      (org-mode)
      (insert contents)
      (goto-char (point-min))
      (setq results (-non-nil (org-map-entries map-fn)))
      (-each (-zip-fill orig-name results '()) 'tag-unify/org-split-temp-buffer-create)
      )
    )
  )
